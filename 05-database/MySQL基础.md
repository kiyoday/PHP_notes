# MYSQL基础知识考察点

## 字段类型

### 整数类型

`TINYINT、 SMALLINT、 MEDIUMINT、INT、 BIGINT`
属性： `UNSIGNED`
长度：可以为整数类型指定**宽度**，例如：INT(11)、对大多数应用
是没有意义的，它不会限制值的合法范围，**只会影响显示字符**的个数

> xint(3) 可以存入值为1234567 ，且不会切断，
> 设置长度是为了 如果设置了 `Zerofill【零填充】` 存入123 会变为 0123，
> 所以 int(0) 也是具有意义的

### 实数类型

`FLOAT、 DOUBLE、 DECIMAL`
`DECIMAL`可存储比 `BIGINT`还大的整数；

可以用于存储精确的小数，相当于存为字符串
FLOAT和 DOUBLE类型支持使用标准的浮点进行近似计算

### 字符串类型

`VARCHAR、CHAR、TEXT、BLOB`
VARCHAR类型用于存储**可变长字符串**，它比char定长类型**更节省空间**
VARCHAR使**用1或2个额外字节记录字符串的长度**，列长度小于
255字节，使用1个字节表示，否则用2个

> `char` 定长 ，如 `char(10)` 不管你存入多长， 都占用10 个字节，用于存储定长的字符串
> `CHAR`会根据需要采用空格进行填充以方便比较
> 如果存储值**经常变更**、**很短**或**定长**，可以选择`char`
> `varchar` 与 `char` 会切断长度长度的字符串 ，超过255字节的只能用`varchar`或者`text`；
> 能用`varchar`的地方不用`text`；

### 枚举

`create table user_sex(sex enum('M'，'F'));`
有时可以使用枚举代替常用的字符串类型
把不重复的集合存储成一个预定义的集合
**非常紧凑**，把列表值压缩到一个或两个字节，会使表大小大大减小
内部存储的是整数，尽量避免**使用数字**作为ENUM枚举的常量，易混乱
排序是按照内部存储的整数进行排序

### 日期和时间类型

尽量使用 `TIMESTAMP`，比 `DATETIME`空间效率高
用整数保存时间戳的格式通常不方便处理
如果需要存储微秒，可以使用 `bigint`存储

```mysql
date 	1000-01-01 ~ 9999-12-31
datetime    1000-01-01 00：00：00 ~ 9999-12-31 23：59：59
timestamp    1970-01-01 00：00：01  ~ 2038-01-19 03：14：07
```

### 列属性

`auto_increment`、`default`、 `not null`、`zerofill`

## 数据表引擎

### InnoDB表引擎

默认`事务型`引擎，最重要最广泛的存储引擎，**性能非常优秀**
数据存储在共享表空间，可以通过配置分开
对`主键查询`的**性能高**于其他类型的存储引擎
内部做了很多优化，从磁盘读取数据时自动在内存构建hash索引
插入数据时自动构建插入缓冲区

通过一些机制和工具支持真正的**热备份**
支持崩溃后的**安全恢复**
支持`行级锁`
支持`外键`

### MYISAM表引擎

5.1版本前， MYISAM是默认的存储引擎
拥有全文索引、压缩、空间函数
`表锁`，**不支持事务和行级锁**，**不支持崩溃后的安全恢复**
表存储在两个文件，MYD和MYI
设计简单，某些场景下性能很好

### 其他表引擎

Archive、 Blackhole、CSV、 Memory

## 锁机制

表锁是日常开发当中常见的问题，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题

### 共享锁(读锁)和排他锁(写锁)

#### 读锁

共享的，不堵塞，多个用户可以同时读一个资源，互不干扰

#### 写锁

排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一人进行写入，防止其他用户读取正在写入的资源。

### 锁粒度

- 表锁，系统性能开销最小，会锁定整张表， MYISAM使用表锁
- 行锁，最大程度地支持`并发`处理，但是也带来了最大的`锁开销`，Innodb实现行级锁

## 事务处理

MYSQL提供事务处理的表引擎： InnoDB
服务器层不管理事务，由下层的`引擎实现`
所以同一个事务中，使用多种存储引擎不靠谱
在非事务的表上执行事务操作 MYSQL不会发出提醒，也不会报错

## 存储过程

 存储过程（Stored Procedure）是在大型数据库系统中，`一组`为了<u>完成特定功能</u>的`SQL 语句集`，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程

- **使用场景**

  当对数据库进行复杂操作时(如对多个表进行Update，Insert，Query，Delete时)

  可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用

  提高重用简化复杂的操作，保证数据的一致性，简化对变动的管理

## 触发器

提供给程序员和数据分析员来保证`数据完整性`的一种方法，它是与
表事件相关的特殊的存储过程，是MySQL在insert、update、delete的时候自动执行的代码块

### 使用场景

可通过数据库中的`相关表`实现`级联更改`
实时监控某张表中的某个字段的更改而需要做出相应的处理
某些业务编号的生成等
滥用会造成数据库及应用程序的维护困难

> [MySQL 视图、函数、存储过程和触发器 简书 详解](https://www.jianshu.com/p/814d8aee700a)

# 高性能索引

## 索引基础

### 索引的基础

存储引擎进行数据查询时先去索引当中找到对应的值，

然后根据匹配的索引找到对应的数据行

### 索引对性能的影响

大大减少服务器需要扫描的`数据量`
帮助服务器`避免排序`和`临时表`
将随机I/O变`顺序I/O`
大大提高查询速度，但是会降低写的速度、占用磁盘

### 索引的使用场景

| 规格       | 方案                             |
| ---------- | -------------------------------- |
| 非常小的表 | 大部分情况下全表扫描效率更高     |
| 中到大型表 | 索引非常有效                     |
| 特大型的表 | 使用分区技术来解决（索引代价高） |

## 索引类型

### 索引类型

索引有很多种类型，都是`实现在存储引擎层`的

| 索引类型 | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| 普通索引 | 最基本的索引，没有任何约束限制                               |
| 唯一索引 | 与普通索引类似，但是具有**唯一性**约束                       |
| 主键索引 | 主键可以与外键构成参照完整性约束，防止数据不一致             |
| 组合索引 | 将`多个列组合`在一起创建索引，可以覆盖多个列                 |
| 外键索引 | 只有 Innodb类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作 |
| 全文索引 | MYSQL自带的全文索引只能用于 MYISAM，并且只能对英文进行全文检索 |

> 一个表只能有一个`主键索引`，可以有多个`唯一索引`
> 主键索引一定是唯一索引，唯一索引不是主键索引
> 主键可以与外键构成参照完整性约束，防止数据不一致

### 创建索引的原则

1. 最适合索引的列是出现在 `WHERE子句中`的列，或连接子句中的列而不是出现在 SELECT关键字后的列
2. 索引列的基数越大，索引的效果越好
3. 对字符串进行索引，应该制定一个`前缀长度`，可以节省大量的索引空间
4. 根据情况创建`复合索引`，复合索引可以提高查询效率
5. 避免创建过多索引，索引会额外占用磁盘空间，降低`写操作`效率
6. 主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率

### 索引的注意事项

1. 复合索引遵循**前缀原则**即`顺序`

    ```mysql
    #创建的索引有顺序，非顺序的索引不生效
    KEY(a， b， c)  #创建 a b c 索引 章、节、段

    WHERE a=l and b=2 and c=3 #生效
    WHERE a=1 and b=2	#生效
    WHERE a=1 	#生效
    #跳过前缀原子
    WHERE b=2 and c=3  	#无效
    WHERE a=1 and c=3	#无效
    ```

2. like查询，`%不能在前`，查询`含有%wang%`会失效，可以使用**全文索引**

    ```mysql
    where name like "wang%"#以wang开头
    ```

3. column is `null`可以使用索引
   
    ```mysql
    where name=null #也是可以使用索引
    ```

4. 如果 MYSQL估计使用索引比`全表扫描`更慢，会放弃使用索引
   
    ```mysql
    如果只有100 条数据 where id>1 and id<100 #会自动转为全表索引
    ```

5. 如果or前的条件中的列有索引，后面的没有，索引都不会被用到
   
    ```mysql
    where name='cpj' or age='12'
    ```

6. 列类型是字符串，查询时一定要给值`加引号`，否则索引失效

    ```mysql
    name varchar(16)
    #存了 "100"
    where name = 100  #虽然能得到值 但是没有使用索引
    ```

# SQL语句编写

## 关联update语句

1. 更新 b 表 的 c1 c2 到 A 表的 c1 c2

```mysql
A(id， sex， par， cl， c2)
B(id， age， cl， c2)
//方法一
update a，b set A.cl= B.cl， A.c2=B.c2
where A.id = B.id and B.age >50
//方法二
update a inner join B on A.id B.id
set A.c1=B.c1，A.c2= B.c2
where Bage >50
```
​		

## 六种关联查询

### 交叉连接 CROSS JOIN

```mysql
SELECT * FROM A，B(C) 或者
SELECT * FROM A CROSS JOIN B (CROSS JOIN C)
```

没有任何关联条件，结果是`笛卡尔积`，结果集会很大，没有意义，很少使用

### 内连接 INNER JOIN

```mysql
SELECT * FROM A， B WHERE A id=Bd或者
SELECT FROM A INNER JOIN B ON A.id=B.id
```

> 内连接:多表中同时符合某种条件的数据记录的集合
>
> 分为三类
>
> - `等值`连接： ON A.id=B.id
> - `不等值`连接： ON A.id>B.id
> - `自`连接： `SELECT* FROM A T1 INNER JOIN A T2 on T1.id=T2.pid`

### 外连接 LEFT JOIN/ RIGHT JOIN

- **左外连接LEFT JOIN**

  LEFT OUTER JOIN，以`左表为主`，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成 LEFT JOIN

- **右外连接RIGHT JOIN**

  RIGHT OUTER JOIN，以`右表为主`，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成 RIGHT JOIN

### 联合查询 UNION与 UNION ALL

```mysql
SELECT* FROM A UNION SELECT* FROM B UNION··
```

就是把`多个结果集集中在一起`， UNION前的结果为基准，

需要注意的是联合查询的`列数要相等`，`相同`的记录行会`合并`

`UNION ALL`不会合并重复的结果集

### 全连接

MySQL`不支持全连接`
可以使用`LEFT JOIN`和`UNION`和`RIGHT JOIN`联合使用

```mysql
SELECT * FROM A LEFT JOIN B ON A.id= B.id UNION
SELECT * FROM A RIGHT JOIN B ON A.id= B.id
```



### 嵌套语句

用一条SQL语句的结果作为另外一条SQL语句的条件

```mysql
SELECT FROM A WHERE id IN(SELECT id FROM B)
```



