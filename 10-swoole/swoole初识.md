## 初识 Swoole

### 前言

------

在之前的教程当中我们已经了解到了php的几种运行模式：

- `CGI` 通用网关接口(Common Gateway Interface)
- `Fast-CGI` 是 `cgi`的升级版本，用 `PHP-FPM(FastCGI Process Manager)` 即 `fast-cgi` 进程管理器
- `mod` 以模块的形式集成进 `Apache` 中，接受 `Apache` 提供的.php文件，并进行解析。
- `CLI` 命令行模式，直接使用 `PHP` 去执行.php文件时便是此模式。

尽管 `CLI` 模式可以完成更多有趣和强大的功能，但大多数php程序员很少使用 `CLI` 模式。

### 起源

Swoole是Rango在2010年底，因为公司业务需要自己实现一个Tcp Socket Server 实现SMT P协议接收数据，但是在当时PHP在这个领域几乎是一片空白，所以Rango自己学习，最终完成了需求；随后便开源了此套系统，希望能帮助其他PHPer解决在这个领域的问题，让PHP从单纯的Web开发扩展到更大的空间。

[以下内容来自于Swoole官方文档](https://wiki.swoole.com/wiki/page/p-originate.html)

> **项目起源**
> Swoole 项目最初的想法是来自于之前所做的一个企业软件项目。当时大概是2010年底，公司产品有一个需求是用户可以任意生成一个 email 地址，然后其他用户可以向这个email发邮件，后台能实时将邮件内容解析成数据，并主动通知用户。当时项目使用PHP开发的，在实现这个需求时遇到了难题，PHP只能依赖其他的STMP服务器，通过pop3协议定时查收新邮件来完成，这样就不是实时的。如果要实现的实时系统必须自己写一个TCP Socket Server实现SMTP协议接收数据。当时PHP在这个领域几乎是空白，没有一套成熟的网络通信框架。为了实现需求，我从socket学起到TCP/IP、IO复用、libevent、多进程，最后终于实现了这套程序。做完这个项目后我就想把这套程序开源出来，希望能帮助其他PHPer解决在这个领域的难题。如果能有这样一个框架，那么PHP就能从单纯地做一个Web网站延伸到更大的空间。
>
> 还有一个重要的原因是PHP程序的性能问题，我最早是学Java出身的，工作后才转行成为一名PHP程序员。在使用PHP开发程序的过程中，我一直在思考的问题 PHP 和 Java 比最大的优势是什么？简单高效， PHP 在请求完成之后会释放所有资源和内存，无须担心内存泄漏。代码的质量无论高低一样运行的很流畅。但同时这也是 PHP 致命的缺点。一旦请求数量上升，并发很高的时候，快速创建资源，又马上释放，使得 PHP 程序运行效率急剧下降。另外一旦项目的功能的越来越复杂，代码增多后，对于 PHP 也会是灾难。这也是 PHP 的框架为什么没有被 PHP 程序员广泛接受，而 Java 不存在这个问题。再好的框架也会被这种低效的方式拖累，导致系统变慢。所以想到了使用 PHP 来开发 PHP 的应用服务器，让 PHP 的代码加载到内存后，拥有更长的生命周期，这样建立的数据库连接和其他大的对象，不被释放。每次请求只需要处理很少的代码，而这些代码只在第一次运行时，被 PHP 解析器编译，驻留内存。另外，之前 PHP 不能实现的，对象持久化、数据库连接池，缓存连接池都可以实现。系统的运行效率会大大提高。
>
> 经过一段时间研究，目前已经初步得到实现。使用 PHP 本身编写出 HTTP 服务器，以独立服务器方式运行，单个程序页面 ( 有对象生成，数据库连接、 smarty 模板操作 ) 的执行时间由原来的 0.0x 秒，下降到 0.00x 秒。使用 Apache AB 并发 100 测试。比传统 LAMP 方式， Request per Second 高出至少 10 倍。在我的测试机上 (Ubuntu10.04 Inter Core E5300 + 2G 内存 ) ， Apache 只跑到 83RPS 。 Swoole Server 可以跑到 1150 多 RPS。
>
> 这个项目就是Swoole的雏形。这个版本一直持续维护了2年多，在这个过程中逐步有了一些经验积累，对这套技术方案的存在问题有了更深入的理解，比如性能差、限制较多无法直接调用操作系统接口、内存管理效率低下。
>
> **入职腾讯**
> 2011年底我入职腾讯，负责朋友网的PHP平台开发工作。惊奇地发现朋友网的同事不光这样想了，他们直接做到了。朋友网团队已经在生产环境中使用了这套方案。朋友网有三架马车，第一个是PWS，这是一个纯PHP编写的WebServer，朋友网线上有600多台服务器运行在PWS上，完全没有使用Apache、PHP-FPM之类的程序。第二个是SAPS，这是使用纯PHP开发的一个分布式队列，当时大概由150台服务器的集群在跑，很多图片裁剪、头像处理、消息同时、数据同步等逻辑全部使用了SAPS做逻辑异步化。第三个是PSF，这是一个PHP实现的Server框架，朋友网很多逻辑层的服务器都是基于PSF实现的。大概有300台左右的集群在运行PSF服务器程序。在朋友网的这段时间，我学到了很多Linux底层、网络通信的知识，积累了很多大型集群高并发环境的网络通信跟踪、调试经验，为开发Swoole打下了一个很好的基础。
>
> **开发Swoole**
> 在这期间也学习了解到了Node.js、Golang这些优秀的技术方案，得到了更多灵感。在2012年的时候就有了新的想法，决定使用C语言重新实现一个性能更强、功能更强大的版本。这就是现在的Swoole扩展。
>
> 现在Swoole已经被很多PHP技术团队用于实际项目的开发工作，国内国外都有。国内知名的有百度订单中心、百度地图、腾讯QQ公众号和企业QQ、战旗直播、360、当当网、穷游等。另外还有很多物联网、硬件、游戏项目也在使用Swoole 。另外基于Swoole的开源框架也越来越多，比如TSF、Blink、swPromise 等等，在Github上也能找到很多Swoole相关的项目和代码。
>
> **名字由来**
> Swoole这个名字不是一个英文单词，是由我创造的一个音近字。我最早想到的名字是叫做 `sword-server`，寓意是为广大PHPer创造一把锋利的剑，后来联想到 `google` 也是凭空创造出来的，所以我就给它命名为 `swoole`。

### 现在

------

随着Swoole进入4.0时代，原2.0时期协程的各种各样的坑，在4.0都得到了解决。 如今的Swoole可以说是真正好用可靠的PHP异步网络引擎。

2018年7月Rango辞去工作，组织了全职的研发团队来开发 Swoole 内核、组件和工具链。在文档、测试、社区运营方面也会投入更多资源。[本段来源](https://www.zhihu.com/question/278846763/answer/474698076)

### Swoole 能做什么

------

[以下内容来源于Swoole官方文档](https://wiki.swoole.com/)
Swoole 是使用 `C` 和 `C++` 语言编写的PHP扩展， 内置了异步非阻塞、多线程的网络IO服务器，PHP程序员仅需处理事件回调即可，无需关心底层。

同时Swoole也提供了许多非常多的内置功能如：

- PHP语言的异步多线程服务器
- 异步TCP/UDP网络客户端
- 异步MySQL
- 异步Redis
- 数据库连接池
- AsyncTask
- 消息队列
- 毫秒定时器
- 异步文件读写
- 异步DNS查询
- Http/WebSocket服务器端/客户端
- Http2.0服务器端/客户端

与大家熟知的 `Workerman` 框架不同，Swoole更像是一个基础库给了开发者一把无比锋利的宝剑，可以按照自己想要的方法去使用。

Swoole绝大部分功能都只能运行在 `CLI` 模式下，也正因为此开发者可以完全的掌控Server的一切，与传统的 `php-fpm` 模式不同，Swoole需要开发者自行接管各种相关事件，和管理变量的生命周期等。

### 与传统Web开发的区别

------

我们知道 `php-fpm` 是 `fast-cgi` 运行模式的进程管理器，当启动Server时 `php-fpm` 会预创建若干个 `fast-cgi` 处理进程； 每当请求到达 `Nginx` 时 `Nginx` 检查到请求的是.php文件时，就将请求转发给 `php-fpm` Server 然后由 `php-fpm` 交给某个空闲的进程处理，当处理完成后由 `php-fpm` 返回给 `Nginx` 然后由 `Nginx` 响应给用户。

传统PHP开发者几乎无需关注这其中发生的过程~~甚至根本不了解~~，正所谓成也萧何败萧何，一方面虽然降低了开发者入门的门槛但另一方面也使得大量的PHP开发者几乎不了解也不懂的真正的服务端开发。

而 `SwooleServer` 则是相当于取代了 `php-fpm` 作为管理器的位置， 由于Swoole 是运行在 `CLI` 模式下， 所以可以常驻运行和以[守护进程](https://www.easyswoole.com/Cn/NoobCourse/PHP/Multiprocess/Deamon.html)运行， 但也正因为如此，也需要开发者自行处理变量的销毁及各种异常和超时的处理。

## Swoole 的运行模式

------

注： **以下内容主要指 `SwooleServer` 。**

### Swoole 做了什么

------

`Swoole` 是 php 的一个扩展，但是他又不是普通的扩展，其最明显的特点就是：**一但运行后就会接管PHP的控制权，进入事件循环。** **当某种IO事件发生时， `Swoole` 会回调开发者设置的指定PHP函数。**

也就是说 `SwooleServer` 更像是一个用 `C` 语言封装好的一个 `Tcp/Udp` 支持 `多线程`， `EventLoop`，`事件驱动`，`异步` 等功能的框架。开发者不需要关心底层的各种实现，直接的在业务层面进行开发即可。

### 什么是IO事件

------

很多 php 程序员没有使用过其他语言开发Server，也不太了解除了php-fpm以外运行模式的php程序，初次使用Swoole时总是会有各种摸不到头脑的事情。其实IO我们经常提起如： `磁盘IO` ，`网络IO` 在这里Swoole所指的IO事件实际上是指 `网络IO` 事件。

在日常生活中你留下了一个邮箱，当有人给你发送邮件的时候，你就会收到邮件提醒；而对于你而言，你并不关心邮件是如何送达的，你只关心你有没有收到邮件，当你收到邮件之后会根据邮件的内容和发送人去做各种各样的处理。在这个比喻中，**Swoole就承担了底层网络事件的监听及各种底层事件处理，当收到邮件(请求)时，会触发收件(接收)提醒，然后将控制权转交给你(预先注册的事件回调函数)，来进行后续的处理。**

### Swoole 的运行流程

------

##### 初始化

```php
<?php

// new 一个SwoolerServer对象 并指定监听端口 和运行模式 以及Socket类型
// 此时的一切一切 都是开发者进行配置的时间，没有任何其他事情发生
$server = new Swoole\Server('0.0.0.0', 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);

// 设置运行参数， 就像你平时做的那样，给$server 对象配置相关的参数
$server->set([
    'worker_num' => 4,    // 工作进程数量
    'daemonize' => true,  // 是否以守护进程模式运行
    'backlog' => 128,     // Listen队列长度
]);

// 注册事件回调函数
// 这里指 当底层Tcp新连接进入事件时 交给Tcp 类的 onConnect 静态方法处理
$server->on('Connect', [Tcp::class, 'onConnect']);
// 这里指 当收到数据时 交给Tcp 类的 onReceive 静态方法处理
$server->on('Receive', [Tcp::class, 'onReceive']);
// 这里指 当Tcp客户端连接关闭时 交给Tcp 类的 onClose 静态方法处理
$server->on('Close', [Tcp::class, 'onClose']);
```

在上面的示例当中，实际上Swoole还尚未启动，但是我们已经预先配置了许多必要的配置条件。鉴于有的新人还尚不了解什么叫做 `回调函数`，在这里我简单的讲解一下:

> 所谓的`回调函数(CallBack)` 就好比是<u>张开了夹子的捕鼠器</u>，我们设定当有老鼠踩到捕鼠器的时候，他会关闭夹子然后捉住老鼠，我们放置捕鼠器的时候，捕鼠器并没有真的抓老鼠。这个设定就是回调，他不立刻执行，会在遇到触发条件(事件)时执行，在上面的示例当中我们放置了3个捕鼠器(回调函数)，我们只需要知道他会在特定老鼠(事件)踩到的时候(发生的时候)去执行我们期望的功能就好。

##### Server Start

```php
// 启动Swoole Server 将由 Swoole 接管php运行
$server->start();
```

至此Swoole 完全的接管了php的运行，并且监听相应端口并当发生事件时去执行开发者自定义的事件回调。

##### 仅仅如此吗？

事实上Swoole 在启动的时候做了非常多的事情:

> Swoole 运行流程图： ![Swoole运行流程图](C:\Users\12605\Desktop\.img\swoole.jpg)
>
> Swoole 进程关系图： ![Swoole进程关系图](C:\Users\12605\Desktop\.img\635680420659.png)

上图中我们可以了解，Swoole 会创建一个 `Manager` 进程专门 管理 `Work` 和 `Task` 进程。 而 `Work` 进程则直接通过 `Unix Socket` 和 `Master` 进程通讯。

### 待续

## Swoole的生命周期

------

#### php-fpm中的生命周期

------

传统基于php-fpm的web开发通常淡化了全局期变量的影响，这对于开发者而言，显然是降低了许多上手难度的；但也导致了许多新人对全局期变量会产生的影响没有深刻理解。

我们知道，php-fpm收到请求后会分配一个work进程去处理这条请求，而work会去读取并执行.php文件(在通常情基于框架的开发中，这个.php文件可能是index.php)。也就是说在传统模式中，每个请求都是独立在自己的进程中执行的，因为进程是隔离的而php-fpm又是同步阻塞的，所以我们可以很好的清楚和了解是谁在什么时候创建了变量、修改了变量、销毁了变量。

##### 简单举个例子

可可酱是商店的一名售货员，这个店只有他一个人。当客户来了之后需要购买一瓶可乐，可可酱检查了货架确认有可乐，随后告诉客户这瓶可乐价格是￥3.5元，客户付钱给可可酱，可可酱收到钱后把可乐交给了客户。

后来发现客人太多，只有可可酱一个人的时候后面的客户需要排队很久，于是老板决定再雇一名售货员，于是加入了小明。

还是上面的场景，但是由于小明的加入，小明和可可酱同时接待了2名客户，可可酱检查了货架确认还有一箱可乐的时候，和客人沟通可乐的价格时，小明的客户需要购买一箱可乐，于是小明就取走了一箱可乐，当可可酱收了钱准备拿可乐的时候，发现没有可乐了，然后被客户打了一顿。

在上面的场景中，就是一个变量被修改而导致后续逻辑混乱的场景，在传统的fpm开发中，往往只会在访问数据库的时候出现这种场景。但是如果假设一个fpm进程可以同时处理多条请求的时候，你如果将用户信息存放在全局变量中，那么你就无法再可靠的判断当前用户是谁了。

# swoole_server中对象的4层生命周期

------

以下内容摘自[swoole文档](https://wiki.swoole.com/wiki/page/354.html)

开发swoole程序与普通LAMP下编程有本质区别。在传统的Web编程中，PHP程序员只需要关注request到达，request结束即可。而在swoole程序中程序员可以操控更大范围，变量/对象可以有四种生存周期。

> 变量、对象、资源、require/include的文件等下面统称为对象

## 程序全局期

在`swoole_server->start`之前就创建好的对象，我们称之为程序全局生命周期。这些变量在程序启动后就会一直存在，直到整个程序结束运行才会销毁。

有一些服务器程序可能会连续运行数月甚至数年才会关闭/重启，那么程序全局期的对象在这段时间持续驻留在内存中的。程序全局对象所占用的内存是`Worker`进程间共享的，不会额外占用内存。

这部分内存会在写时分离（`COW`），在`Worker`进程内对这些对象进行写操作时，会自动从共享内存中分离，变为**进程全局**对象。

> 程序全局期`include`/`require`的代码，必须在整个程序`shutdown`时才会释放，`reload`无效

## 进程全局期

swoole拥有进程生命周期控制的机制，一个`Worker`子进程处理的请求数超过max_request配置后，就会自动销毁。`Worker`进程启动后创建的对象（onWorkerStart中创建的对象），在这个子进程存活周期之内，是常驻内存的。onConnect/onReceive/onClose 中都可以去访问它。

> 进程全局对象所占用的内存是在当前子进程内存堆的，并非共享内存。对此对象的修改仅在当前`Worker`进程中有效
> 进程期include/require的文件，在`reload`后就会重新加载

## 会话期

`onConnect`到`onClose`是一次TCP的会话周期，http keep-alive时，一个连接可能会有多个request。 http是无状态的，一个用户可能也不止一个连接，可以通过创建一个session来关联同一个用户的不同请求。

## 请求期

请求期就是指一个完整的请求发来，也就是`onReceive`收到请求开始处理，直到返回结果发送`response`。这个周期所创建的对象，会在请求完成后销毁。

swoole中请求期对象与普通PHP程序中的对象就是一样的。请求到来时创建，请求结束后销毁。

### 总结

------

在Swoole中，一个work进程处理完请求后并不会销毁(甚至可能同时处理多个请求)，所以务必要明确你创建的变量的生命周期，以防止出现逻辑上的问题。